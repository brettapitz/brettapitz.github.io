<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>comp-sci on Brett Apitz is Learning Stuff</title>
    <link>https://brettapitz.github.io/tags/comp-sci/</link>
    <description>Recent content in comp-sci on Brett Apitz is Learning Stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 29 Mar 2021 12:33:46 -0500</lastBuildDate><atom:link href="https://brettapitz.github.io/tags/comp-sci/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Translating GAS to NASM, part 4</title>
      <link>https://brettapitz.github.io/posts/groundup4/</link>
      <pubDate>Mon, 29 Mar 2021 12:33:46 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/groundup4/</guid>
      <description>This chapter was a project. Not only was there far more code than any previous chapter, but I also put off learning make until I was nearly finished, so I spent a whooooole lot of time re-assembling and re-linking. For anyone similarly ignorant of the wonders of makefiles, you can grab mine here (or learn about them here). Store the makefile in the same directory as your ASM files and enter make in your terminal to handle all your assembling and linking.</description>
    </item>
    
    <item>
      <title>Translating GAS to NASM, part 3</title>
      <link>https://brettapitz.github.io/posts/groundup3/</link>
      <pubDate>Fri, 05 Mar 2021 11:23:29 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/groundup3/</guid>
      <description>Chapter 5 introduces file manipulation, which means more interaction with the operating system. All system calls changed with the move to x86_64, so whenever they come up in the book I&amp;rsquo;ll have a lot of researching and translating to do. For those of us with terrible memories, we&amp;rsquo;ve also got symbol declarations for constants now, which are only slightly different in NASM. Uninitialized data declaration syntax brings us the second appearance of NASM&amp;rsquo;s bwdqtoyz size-type suffixes, for which I made my own mnemonic: &amp;lsquo;Black and White Dairy Queen TOYZ&amp;rsquo;.</description>
    </item>
    
    <item>
      <title>Translating GAS to NASM, part 2</title>
      <link>https://brettapitz.github.io/posts/groundup2/</link>
      <pubDate>Sat, 27 Feb 2021 19:38:29 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/groundup2/</guid>
      <description>Chapter 4 covers basic functions, and there&amp;rsquo;s not a lot to go over - function syntax is very similar between GAS and NASM.
A few things to note:
 GAS uses a new syntax for indexing memory using the base pointer register: x($ebp), where x is an integer number of bytes away from the pointer. NASM uses the same syntax as the previous chapter, with rbp used in pointer math in square brackets.</description>
    </item>
    
    <item>
      <title>Translating GAS to NASM, part 1</title>
      <link>https://brettapitz.github.io/posts/groundup1/</link>
      <pubDate>Mon, 15 Feb 2021 14:44:00 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/groundup1/</guid>
      <description>Programming from the Ground Up by Jonathan Bartlett is a fantastic introduction to coding in assembly, but the syntax it uses is a bit outdated. While searching for more modern standards, I had trouble finding much related to the GNU Assembler, but plenty for NASM, the Netwide Assembler, which seems to be a lot more common.
So, in the interest of keeping my studies relevant, I decided to translate the coding examples into modern 64-bit NASM.</description>
    </item>
    
    <item>
      <title>Sorting in Python</title>
      <link>https://brettapitz.github.io/posts/pythonsort/</link>
      <pubDate>Sat, 13 Feb 2021 16:07:59 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/pythonsort/</guid>
      <description>Continuing MIT&amp;rsquo;s Data Structures and Algorithms course today, with my Python code for insertion sort, merge sort, and heap sort.
In all three, I generated a list of n random integers between 0 and n, sorted the list, and then printed the first and last elements to make sure they were expected values, since printing the whole list would take forever with large values of n.
Merge sort came out on top, with heap taking ~50% longer, and insertion taking almost as long to sort 10,000 items as merge took to sort 1,000,000.</description>
    </item>
    
    <item>
      <title>Document Distance Optimization</title>
      <link>https://brettapitz.github.io/posts/docdistance/</link>
      <pubDate>Sat, 13 Feb 2021 13:03:08 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/docdistance/</guid>
      <description>One of the first assignments in MIT&amp;rsquo;s Data Structures and Algorithms course on OpenCourseWare is analyzing the evolution of a document distance program across eight iterations. You can download the .py files here, in the Lecture Notes ZIP for Lecture 2.
I&amp;rsquo;ll be using these variables, and looking at the code function by function. Number of Wordsn Number of LinesL Number of Charactersc Number of Unique Wordsu Average Words per Linew  read_file() The only change made to this function is a switch in v8 from readlines(), which returns a list with every line in the file represented as a separate string, to read(), which returns the entire file as a single string.</description>
    </item>
    
  </channel>
</rss>
