<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>comp-sci on Brett Apitz is Learning Stuff</title>
    <link>https://brettapitz.github.io/tags/comp-sci/</link>
    <description>Recent content in comp-sci on Brett Apitz is Learning Stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 27 Feb 2021 19:38:29 -0500</lastBuildDate><atom:link href="https://brettapitz.github.io/tags/comp-sci/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Translating GAS to NASM, part 2</title>
      <link>https://brettapitz.github.io/posts/groundup2/</link>
      <pubDate>Sat, 27 Feb 2021 19:38:29 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/groundup2/</guid>
      <description>Chapter 4 covers basic functions.
 GAS uses a new syntax for indexing memory using the base pointer register: x($ebp), where x is an integer number of bytes away from the pointer. NASM uses the same syntax as the previous chapter, with rbp used in pointer math in square brackets. Though it&amp;rsquo;s used throughout the book, the line .type foo, @function is not required in GAS. The .type directive is used to define the type of a symbol (in this case defining foo as a function), and is useful for debugging or making a function available in other programs.</description>
    </item>
    
    <item>
      <title>Translating GAS to NASM, part 1</title>
      <link>https://brettapitz.github.io/posts/groundup1/</link>
      <pubDate>Mon, 15 Feb 2021 14:44:00 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/groundup1/</guid>
      <description>Programming from the Ground Up by Jonathan Bartlett is a fantastic introduction to coding in assembly, but the syntax it uses is a bit outdated. While searching for more modern standards, I had trouble finding much related to the GNU Assembler, but plenty for NASM, the Netwide Assembler, which seems to be a lot more common.
So, in the interest of keeping my studies relevant, I decided to translate the coding examples into modern 64-bit NASM.</description>
    </item>
    
    <item>
      <title>Sorting in Python</title>
      <link>https://brettapitz.github.io/posts/pythonsort/</link>
      <pubDate>Sat, 13 Feb 2021 16:07:59 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/pythonsort/</guid>
      <description>Continuing MIT&amp;rsquo;s Data Structures and Algorithms course today, with my Python code for insertion sort, merge sort, and heap sort.
In all three, I generated a list of n random integers between 0 and n, sorted the list, and then printed the first and last elements to make sure they were expected values, since printing the whole list would take forever with large values of n.
Merge sort came out on top, with heap taking ~50% longer, and insertion taking almost as long to sort 10,000 items as merge took to sort 1,000,000.</description>
    </item>
    
    <item>
      <title>Document Distance Optimization</title>
      <link>https://brettapitz.github.io/posts/docdistance/</link>
      <pubDate>Sat, 13 Feb 2021 13:03:08 -0500</pubDate>
      
      <guid>https://brettapitz.github.io/posts/docdistance/</guid>
      <description>One of the first assignments in MIT&amp;rsquo;s Data Structures and Algorithms course on OpenCourseWare is analyzing the evolution of a document distance program across eight iterations. You can download the .py files here, in the Lecture Notes ZIP for Lecture 2.
I&amp;rsquo;ll be using these variables, and looking at the code function by function. Number of Wordsn Number of LinesL Number of Charactersc Number of Unique Wordsu Average Words per Linew  read_file() The only change made to this function is a switch in v8 from readlines(), which returns a list with every line in the file represented as a separate string, to read(), which returns the entire file as a single string.</description>
    </item>
    
  </channel>
</rss>
